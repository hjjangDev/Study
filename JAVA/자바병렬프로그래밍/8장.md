
## 8장
##### 스레드 풀을 설정하고 튜닝하는 데 사용 가능한 고급 옵션과, 작업 실행 프레임웍을 사용할 때 흔히 발생할 수 있는 어려움을 해결하는 방법과 Executor를 사용하는 예제를 소개   
   
- 8.1 작업과 실행 정책 간의 보이지 않은 연결 관계   
- 8.2 스레드 풀 크기 조정   
- 8.3 ThreadPoolExecutor 설정   
- 8.4 ThreadPoolExecutor 상속   
- 8.5 재귀 함수 병렬화   

## 8.1 작업과 실행 정책 간의 보이지 않은 연결 관계

일정한 조건을 갖춘 실행 정책이 필요한 작업에는 다음과 같은 것들이 있다.   
   
`의존성이 있는 작업`  
  >  - 독립적인 작업이 아닌 의존성을 갖는 작업의 경우에는 활동성 문제가 발생할수있기 때문에 보이지 않는 조건을 면밀히 조사하고 관리해야한다.   
  **=> 스레드 풀의 크기를 충분히 잡아서 작업이 큐에서 대기하거나 등록되지 못하는 상황이 없도록 해야한다.**   
     
`스레드 한정 기법을 사용하는 작업`  
 >   - Executor 프레임웍이 단일 스레드로 동작해야 한다는 조건이 생기기 때문에 작업과 실행 정책 간에 보이지 않는 연결고리가 걸려 있는 상황   
 >   - 따라서 이런 경우에는 단일 스레드를 사용하는 풀대신 여러개의 스레드를 사용하는 풀로 변경하면 스레드 안전성을 쉽게 잃을 수 있다.   
  **=> 반드시 순차적으로 실행돼야 한다.**   
     
`응답시간이 민감한 작업`  
> - 단일 스레드로 동작하는 Executor에 오랫동안 실행될 작업을 등록하거나, 서너개의 스레드로 동작하는 풀에 실행 시간이 긴 작업을 몇 개만 등록하더라도 해당 Executor를 중심으로 움직이는 화면 관련 부분은 응답 성능이 크게 떨어질수밖에 없다.   
   
`ThreadLocal 을 사용한 작업`    
 > - 스레드풀에 속한 스레드에서 ThreadLocal 을 사용할때에는 현재 실행중인 작업이 끝나면 더이상 사용하지 않을 값만 보관해야한다   
 > - ThreadLocal 을 편법으로 활용해 작업 간에 값을 전달하는 용도로 사용해서는 안된다.   
 > - 특정 작업을 실행하고자 할 때 그에 맞는 실행 정책을 요구하는 경우도 있고, 특정 실행 정책 아레에서는 실행되지 않는 경우도 있다.   
   
**결론 : 작업을 구현할 때는 나중에 유지보수를 진행할 때 해당 작업과 호화되지 않는 실행 정책 아래에서 실행하도록 변경해 어플리케이션의 안전성을 해치거나 실행되지 않는 경우를 막을 수 있도록 실행 정책과 관련된 내용을 문서로 남겨야 한다.**   
   
### 8.1.1 스레드 부족 데드락 thread starvation deadlock   
> - 스레드 풀에서 다른 작업에 의존성을 갖고 있는 작업을 실행시킨다면 데드락에 걸릴 가능성이 높다.   
> - 단일 스레드로 동작하는 Executor 에서 다른 작업을 큐에 등록하고 해당작업이 실행된 결과를 가져다 사용하는 작업을 실행하면, 데드락이 제대로 걸린다.   
> - 스레드 풀의 크기가 크더라도 실행되는 모든 스레드가 큐에 쌓여 아직 실행되지 않은 작업의 결과를 받으려고 대기중이라면 동일한 상황이 발생할 수 있다.   

**특정 자원을 확보하고자 계속해서 대기하거나 풀 내부의 다른 작업이 실행돼야 알 수 있는 조건이 만족하기를 기다리는 것처럼 끝없이 계속 대기할 가능성이 있는 기능을 사용하는 작업이 풀에 등록된 경우에는 언제든지 발생 가능 **   
   
**스레드 부족 데드락 문제가 발생하는 예제**
~~~java
public class ThreadDeadLock {
//머리글과 꼬리글을 가져오길 기다렸다가 가져오게되면 머리글, 본문, 꼬리글을 하나로 모아 최종페이지를 만들어 내는 예제

    ExecutorService exec = Executors.newSingleThreadExecutor();
    
    public class RenderPageTask implements Callable<String>{

        @Override
        public String call() throws Exception {
            Future<String> header, footer;
            header = exec.submit(new LoadFileTask("header.html"));
            footer = exec.submit(new LoadFileTask("footer.html"));
            String page = renderBody();
            return header.get() + page + footer.get(); // 해당 부분 데드락 발생
       
        }
    }
}
~~~

- Executor 에서 스레드를 하나만 쓰도록 구현한다면 ThreadDeadLock 클래스는 항상 데드락에 걸린다.   
- 이것처럼 배리어 barrier 를 사용해 서로 동작을 조율하는 작업 역시 풀의 크기가 충분히 크지 않다면 스레드 부족 데드락이 발생 할 수 있다.   
   
**결론 : 완전히 독립적이지 않은 작업을 Executor에 등록할때 항상 스레드 부족 데드락이 발생할 수 있다는 사실을 염두에 둬야하며, 작업을 구현한 코드나 Executor를 설정하는 설정파일등에 항상 스레드 풀의 크기나 설정에 대한 내용을 설명해야 한다.**   
    
### 8.1.2 오래 실행 되는 작업   
- 데드락이 발생하지 않는다 하더라도 특정 작업이 예상보다 긴 시간동안 종료되지 않고 실행되면 스레드 풀의 응답 속도에 문제점이 생긴다.   
- 오래 실행되는 작업이 있다면 스레드 풀은 전체적인 작업 실행 과정에 어려움을 겪게 되며 금방 끝나는 작업이 실행되는 속도에도 영향을 미친다.   
- 오래 실행될 것이라고 예상되는 작업이 대략 몇개인지를 알고있을때 그 개수에 비해 스레드 풀의 크기가 상당히 작은 수준이라면 시간이 지나면서 스레드 풀에 속한 스레드 가운데 상당수가 오래 실행되는 작업에 잡혀있을 가능성이 크다.   
- 스레드 풀을 사용하는 도중에 모든 스레드에서 실행중인 작업이 대기상태에 빠지는 경우가 자주 발생한다면 스레드풀의 크기가 작다는것으로 이해할수있다.   
   
> 자바 플랫폼 라이브러리에서 제공하는 대부분의 블로킹 메소드는 시간이 제한되지 않는것과 시간이 제한된 것이 함께 만들어져 있다   
> Thread.join,BlockingQueue.put, CoutDownLatch.await, Selector.select 메소드 등   
> **대기하는 도중에 지정한 시간이 지나면 해당 작업이 제대로 실행되지 못했다고 기록해두고 일단 종료시킨 다음 큐의 맨 뒤에 다시 추가하는 등의 대책을 세울 수 있다**   
> 이런 경우 성공하건 성공하지 못하건 작업은 계속 움직이며 큐에 쌓여있던 금방 끝나는 작업을 실행할수있도록 스레드를 비워주는 효과가 있다.
   
## 8.2 스레드 풀 크기 조정
- 스레드풀의 가장 이상적인 크기는 스레드풀에서 실행할 작업의 종류와 스레드 풀을 활용할 애플리케이션의 특성에 따라 결정한다.
- 하드코딩하여 고정하는 방법은 좋은 방법이 아니며 설정파일이나 Runtime.availableProcessors 등의 메소드 결과 값에 따라 동적으로 지정해야 한다.
- 특별한 공식은 없고 너무 크다/ 너무 작다 와 같이 극단적인 크기만 아니면 됨

`스레드 풀의 크기를 적절하게 산정하는 법`
> - 처리해야 할 작업이 시작해서 끝날때까지 실제 작업하는 시간 대비 대기 시간의 비율을 구해봐야 함
> - 컴퓨터 환경이 어느정도인지 확인하고, 확보하고 있는 자원의 양과 해야 할 작업이 어떻게 동작하는지도 알아야한다.
> - 처리할 작업의 종류가 다양하다면 각자의 작업 부하에 따라 섬세하게 성능을 조절할 수 있도록 여러개의 스레드풀을 만들어 활용하는 방법도 있다.
> - CPU를 많이 사용하는 작업의 경우 : N개의 CPU를 탑재하고 있는 하드웨어에서 스레드 풀을 사용할 때는 스레드의 개수를 N+1로 맞추면 최적의 성능을 발휘
> - I/O 작업이 많거나 블로킹 작업을 해야하는 경우 : 스레드 풀의 크기를 훨씬 크게 잡아야하는 필요가 있음

`스레드풀의 크기를 구하는 수식`  
> **Nthread = Ncpu * Ucpu * (1+W/C)**   
> Ncpu = CPU의 개수   
> Ucpu = 목표로 하는 CPU 활용도 (0 <= Ucpu <= 1)   
> W/C = 작업시간 대비 대기시간의 비율   
   
`CPU 의 개수는 Runtime클래스의 availableProcessors 메소드로 알수있다.`   
> **int N_CPUS = Runtime.getRuntime().availableProcessors();**
        

## 8.3 ThreadPoolExecutor 설정   
  **ThreadPoolExecutor : Executors 클래스에 들어있는 newCachedTreadPool, newFixedTrheadPool, newScheduledThreadPool과 같은 팩토리 메소드에서 생성해주는 Executor에 대한 기본적인 내용이 구현되어 있는 클래스이다. 유연하면서도 안정적이고 여러가지 설정을 통해 입맛에 맞게 바꿔 사용할수있다.**   

### 8.3.1 스레드 생성과 제거
풀의 코어 크기나 최대 크기, 스레드 유지 시간 등의 값을 통해 스레드가 생성되고 제거되는 과정을 조절할수있다.   
코어 크기: 스레드 풀을 사용할때 원하는 스레드의 개수   
  - 스레드 풀 클래스는 실행할 작업이 없다하더라도 스레드의 개수를 최대한 코어 크기에 맞추도록 되어있다.   
  - 큐에 작업이 가득 차지 않는 이상 스레드의 수가 코어 크기를 넘지 않는다.   
  - 풀의 최대 크기는 동시에 얼마나 많은 개수의 스레드가 동작할수있는지를 제한하는 최대값이다. 풀의 스레드 개수가 코어 크기를 넘어설때 제거될수있다.   
### 8.3.2 큐에 쌓인 작업 관리
크기가 제한된 스레드 풀에서는 동시에 실행될 수 있는 스레드의 개수가 제한되어 있다.    
(단일 스레드로 동작하는 풀은 일종의 특별 케이스라고 볼 수 있는데, 이런 스레드 풀은 스레드가 하나 뿐이기 때문에 병렬로 실행되는 경우가 없으며, 스레드 한정 기법을 사용하는 경우 스레드 안전성을 보장할수있다.)   
   
ThreadPoolExecutor를 생성할때 작업을 쌓아둘 큐로 BlockingQueue를 지정할수있다.
스레드 풀에서 작업을 쌓아둘 큐에 적용할 수 있는 전략에는 세가지가 있다.
1. 큐에 크기 제한을 두지 않는 방법
2. 큐의 크기를 제한하는 방법
3. 작업을 스레드에 직접 넘겨주는 방법   
   
작업을 쌓는 방법은 풀의 크기를 지정하는것과 같은 여러가지 설정과 연관되어있다.
newFixedThreadPool 메소드와 newSingleThreadExecutor 메소드에서 생성하는 풀은 기본 설정으로 크기가 제한되지 않은 LinkedBlockingQueue를 사용한다.
스레드 풀의 모든 작업이 등록되면 해당 작업은 큐에 쌓이게되며, 작업이 처리되는 속도보다 작업이 추가되는 속도가 빠르면 큐에 끄없이 계속해서 작업이 쌓일수있다.
   
자원 관리 측면에서는 ArrayBlockingQueue 또는 크기가 제한된 LinkedBlockingQueue나 PriorityBlockingQueue와 같이 큐의 크기를 제한시켜 사용하는 방법이 훨씬 안정적이다.   
크기가 제한된 큐를 사용하면 자원 사용량을 한정시킬수있다는 장점이 있지만, 큐가 가득 찼을때 새로운 작업을 등록하려는 상황을 처리해야하는 문제가 생긴다.   

> 스레드 풀에서 실행할 작업이 서로 의존성을 갖는 작업일때 크기가 고정된 풀보다는 **newChachedThreadPool** 팩토리 메소드가 생성해주는 Executor를 사용하여 스레드 부족 데드락에 걸릴 가능성을 줄인다.

### 8.3.3 집중 대응 정책
- 크기가 제한된 큐에 작업이 가득차면 집중대응정책이 동작한다.
- ThreadPoolExecutor의 집중 대응 정책은 setRejectedExecutionHandler메소드를 사용해 원하는 정책으로 변경할수있다
- 집중 대응 정책은 이미 종료된 스레드 풀에 작업을 등록하려는 경우에도 동작한다.
- 기본적으로 사용하는 집중 대응 정책은 중단 **abort 정책**이며, RejectedExcutionException을 던진다. execute 메소드를 호출하는 스레드는 RejectedExcutionException을 잡아서 작업을 더 이상 추가할 수 없는 상황에 직접 대응해야 한다.   
- **제거 discard** 정책은 큐에 작업을 더 이상 쌓을수없다면 방금 추가시키려고 했던 정책을 아무 반응 없이 제거한다.   
 이와 비슷한 **오래된 항목 제거 discard oldest** 정책은 큐에 쌓은 항목 중 가장 오래되어 다음번에 실행될 예정이던 작업을 제거하고, 추가하고자 했던 작업을 큐에 다시 추가한다.   
- **호출자 실행 caller runs** 정책은 작업을 제거해버리거나 예외를 던지지 않으면서 큐의 크기를 초과하는 작업을 프로듀서에게 거꾸로 넘겨 작업 추가 속도를 늦출수있도록 일종의 속도 조절 방법으로 사용한다.   
- 스레드 풀에 적용할 집중 대응 정책을 선택하거나 실행 정책의 다른 설정을 변경하는 일은 Executor를 생성할때 지정한다.   

~~~java
//스레드의 개수와 작업 큐의 크기가 제한된 스레드 풀을 만들면서 호출자 실행 정책을 지정하는 예제

ThreadPool Executor executor = new ThreadPoolExecutor(N_THREADS, N_THREADS, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>(CAPACITY));
executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
~~~
   
- 작업 큐가 가득 찼을때 대기하도록 하는 집중 대응 정책은 따로 없지만 Semaphore를 사용하면 작업 추가 속도를 적절한 범위 내에서 제한할수있다.
  이러한 경우에는 큐의 크기에 제한을 두지 않아야 하고 스레드 풀의 스레드 개수와 큐에서 대기하도록 허용하고자 하는 최대 작업 개수를 더한 값을 세마포어의 크기로 지정하면 된다.   
  
### 8.3.4 스레드 팩토리
- 스레드 풀에서 새로운 스레드를 생성해야할 시점이 되면 새로운 스레드는 항상 스레드 팩토리를 통해 생성한다.
- 기본값으로 설정된 스레드팩토리에서는 데몬이 아니면서 아무런 설정도 변경하지 않은 새로운 스레드를 생성하도록 되어있다.

### 8.3.5 ThreadPoolExecutor 생성 이후 설정 변경
- ThreadPoolExecutor를 생성할때 생성 메소드에 넘겨줬던 설정값은 대부분 여러가지 **set 메소드**를 사용해 생성된 이후에도 얼마든지 변경할수있다.   
- unconfigurableExecutorService 메소드는 현재 만들어져있는 ExecutorService를 넘겨받은 다음 ExecutorService의 메소드만을 외부에 노출하고 나머지는 가리도록 한꺼풀 덮어 씌워 더 이상은 설정을 변경하지 못하도록할수있다.   
- 스레드 풀을 사용하지 않는 newSingleThreadExecutor 메소드는 TrheadPoolExecutor 인스턴스를 만들어주는대신 단일 스레드라는 기능에 맞춰 한꺼풀 덮어 씌운 ExecutorService를 생성한다. 하나의 스레드를 사용하는 스레드 풀을 사용한다 해도, 두개 이상의 작업이 병렬로 동시에 처리되어서는 안된다는 규칙은 그대로 보장한다.


> 설정을 변경할 가능성이 있는 외부 코드에서도 직접 구현한 Executor 클래스의 설정을 변경하지 못하도록하려면 unconfigurableExecutorService 메소드를 사욯하자   
   
## 8.4 ThreadPoolExecutor 상속
ThreadPoolExecutor는 애초에 상속받아 기능을 추가할수있도록 만들어졌다.      
하위 클래스가 오버라이드해 사용할 수 있도록 beforeExecute, afterExecute, terminated와 같은 여러가지 훅도 제공하고 있고 이런것들을 사용해 훨씬 다양한 기능을 구사할수있다.      

`beforeExecute, afterExecute 메소드`   
    - 작업을 실행할 스레드의 내부에서 호출하도록 되어 있으며, 로그 메시지를 남기거나 작업 실행 시점이 언제인지 기록해두거나 실행 상태를 모니터링 하거나 기타 다양한 통계 값을 뽑는 등의 작업을 하기에 적당하다   
    - 특히 afterExecute 메소드는 run 메소드가 정상적으로 종료되거나 아니면 예외가 발생해 Exception을 던지고 종료되는 등의 어떤 상황에서도 항상 호출됨   
    - Error 때문에 작업이 중단되면 afterExecute 메소드가 실행되지 않음   
    - beforeExecute에서 RuntimeException이 발생하면 해당 작업도 실행되지 않고 afterExecute 메소드 역시 실행되지 않음   
`terminated 메소드`    
    - 스레드 풀이 종료 절차를 마무리한 이후, 즉 모든 작업과 모든 스레드가 종료되고 나면 terminated 훅 메소드를 호출함   
    - Executor가 동작하는 과정에서 사용했던 각종 자원을 반납하는 등의 일을 처리하거나 여러가지 알람이나 로그 출력, 다양한 통계 값을 확보하는 등의 작업을 진행하기에 적당한 메소드이다.   

## 8.5 재귀 함수 병렬화
특정 작업을 여러 번 실행하는 반복문이 있을 때, 반복되는 각 작업이 서로 독립적이라면 병렬화해서 성능의 이점을 얻을 수 있다.   
특히 반복문 내부의 작업을 개별적인 작업으로 구분해 실행하느라 추가되는 약간의 부하가 부담되지 않을 만큼 적지 않은 시간이 걸리는 작업이라야 더 효과를 볼 수 있다.


## 요약
Executor 프레임웍은 작업을 병렬로 동작시킬 수 있는 강력함과 유연성을 고루 갖추고있따.
스레드를 생성하거나 제거하는 정책이나 큐에 쌓인 작업을 처리하는 방법, 작업이 밀려 있을 때 밀린 작업을 처리하는 방법 등의 조건을 설정해 입맛에 맞게 튜닝할수있는 옵션도 제공하고 있으며   
여러가지 훅 메소드를 사용해 필요한 기능을 확장해 사용할수있다. 강력하면서도 유연성이 높은 프레임웍에서 자주 발생하는 일이지만, 여러가지 설정 가운데 서로 잘 맞지 않는설정이 있을 수 있다.   
예를 들어 특정 종류의 작업은 일정한 실행 정책 아래에서만 제대로 동작하기도 하고, 특이한 조합을 사용하면 예측할수없는 이상한 형태로 작업이 실행되기도 한다는 점을 주의하자


## 참고
책 자바 병렬 프로그래밍 8장
