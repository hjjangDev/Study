
## 8장
**스레드 풀을 설정하고 튜닝하는 데 사용 가능한 고급 옵션과, 작업 실행 프레임웍을 사용할 때 흔히 발생할 수 있는 어려움을 해결하는 방법과 Executor를 사용하는 예제를 소개**

8.1 작업과 실행 정책 간의 보이지 않은 연결 관계
8.2 스레드 풀 크기 조정
8.3 ThreadPoolExecutor 설정
8.4 ThreadPoolExecutor 상속
8.5 재귀 함수 병렬화

## 8.1 작업과 실행 정책 간의 보이지 않은 연결 관계

일정한 조건을 갖춘 실행 정책이 필요한 작업에는 다음과 같은 것들이 있다.
**- 의존성이 있는 작업**
    - 독립적인 작업이 아닌 의존성을 갖는 작업의 경우에는 활동성 문제가 발생할수있기 때문에 보이지 않는 조건을 면밀히 조사하고 관리해야한다.
  => 스레드 풀의 크기를 충분히 잡아서 작업이 큐에서 대기하거나 등록되지 못하는 상황이 없도록 해야한다.**

**- 스레드 한정 기법을 사용하는 작업**
    - Executor 프레임웍이 단일 스레드로 동작해야 한다는 조건이 생기기 때문에 작업과 실행 정책 간에 보이지 않는 연결고리가 걸려 있는 상황
    - 따라서 이런 경우에는 단일 스레드를 사용하는 풀대신 여러개의 스레드를 사용하는 풀로 변경하면 스레드 안전성을 쉽게 잃을 수 있다.
  => 반드시 순차적으로 실행돼야 한다.
    
**- 응답시간이 민감한 작업**
    - 단일 스레드로 동작하는 Executor에 오랫동안 실행될 작업을 등록하거나, 서너개의 스레드로 동작하는 풀에 실행 시간이 긴 작업을 몇 개만 등록하더라도 해당 Executor를 중심으로 움직이는 화면 관련 부분은 응답 성능이 크게 떨어질수밖에 없다.
  
**- ThreadLocal 을 사용한 작업**
    - 스레드풀에 속한 스레드에서 ThreadLocal 을 사용할때에는 현재 실행중인 작업이 끝나면 더이상 사용하지 않을 값만 보관해야한다
    - ThreadLocal 을 편법으로 활용해 작업 간에 값을 전달하는 용도로 사용해서는 안된다.
    - 특정 작업을 실행하고자 할 때 그에 맞는 실행 정책을 요구하는 경우도 있고, 특정 실행 정책 아레에서는 실행되지 않는 경우도 있다.

**결론 : 작업을 구현할 때는 나중에 유지보수를 진행할 때 해당 작업과 호화되지 않는 실행 정책 아래에서 실행하도록 변경해 어플리케이션의 안전성을 해치거나 실행되지 않는 경우를 막을 수 있도록 실행 정책과 관련된 내용을 문서로 남겨야 한다.**

### 8.1.1 스레드 부족 데드락 thread starvation deadlock 
    - 스레드 풀에서 다른 작업에 의존성을 갖고 있는 작업을 실행시킨다면 데드락에 걸릴 가능성이 높다.
    - 단일 스레드로 동작하는 Executor 에서 다른 작업을 큐에 등록하고 해당작업이 실행된 결과를 가져다 사용하는 작업을 실행하면, 데드락이 제대로 걸린다.
    - 스레드 풀의 크기가 크더라도 실행되는 모든 스레드가 큐에 쌓여 아직 실행되지 않은 작업의 결과를 받으려고 대기중이라면 동일한 상황이 발생할 수 있다.
특정 자원을 확보하고자 계쏙해서 대기하거나 풀 내부의 다른 작업이 실행돼야 알 수 있는 조건이 만족하기를 기다리는 것처럼 끝없이 계속 대기할 가능성이 있는 기능을 사용하는 작업이 풀에 등록된 경우에는 언제든지 발생 가능

스레드 부족 데드락 문제가 발생하는 예제
~~~java
public class ThreadDeadLock {
//머리글과 꼬리글을 가져오길 기다렸다가 가져오게되면 머리글, 본문, 꼬리글을 하나로 모아 최종페이지를 만들어 내는 예제

    ExecutorService exec = Executors.newSingleThreadExecutor();
    
    public class RenderPageTask implements Callable<String>{

        @Override
        public String call() throws Exception {
            Future<String> header, footer;
            header = exec.submit(new LoadFileTask("header.html"));
            footer = exec.submit(new LoadFileTask("footer.html"));
            String page = renderBody();
            return header.get() + page + footer.get(); // 해당 부분 데드락 발생
       
        }
    }
}
~~~
- Executor 에서 스레드를 하나만 쓰도록 구현한다면 ThreadDeadLock 클래스는 항상 데드락에 걸린다.
- 이것처럼 배리어 barrier 를 사용해 서로 동작을 조율하는 작업 역시 풀의 크기가 충분히 크지 않다면 스레드 부족 데드락이 발생 할 수 있다.
**결론 : 완전히 독립적이지 않은 작업을 Executor에 등록할때 항상 스레드 부족 데드락이 발생할 수 있다는 사실을 염두에 둬야하며, 작업을 구현한 코드나 Executor를 설정하는 설정파일등에 항상 스레드 풀의 크기나 설정에 대한 내용을 설명해야 한다.

### 8.1.2 오래 실행 되는 작업
- 데드락이 발생하지 않는다 하더라도 특정 작업이 예상보다 긴 시간동안 종료되지 않고 실행되면 스레드 풀의 응답 속도에 문제점이 생긴다.
- 오래 실행되는 작업이 있다면 스레드 풀은 전체적인 작업 실행 과정에 어려움을 겪게 되며 금방 끝나는 작업이 실행되는 속도에도 영향을 미친다.
- 오래 실행될 것이라고 예상되는 작업이 대략 몇개인지를 알고있을때 그 개수에 비해 스레드 풀의 크기가 상당히 작은 수준이라면 시간이 지나면서 스레드 풀에 속한 스레드 가운데 상당수가 오래 실행되는 작업에 잡혀있을 가능성이 크다.
- 스레드 풀을 사용하는 도중에 모든 스레드에서 실행중인 작업이 대기상태에 빠지는 경우가 자주 발생한다면 스레드풀의 크기가 작다는것으로 이해할수있다.

      자바 플랫폼 라이브러리에서 제공하는 대부분의 블로킹 메소드는 시간이 제한되지 않는것과 시간이 제한된 것이 함께 만들어져 있다
      Thread.join,BlockingQueue.put, CoutDownLatch.await, Selector.select 메소드 등
      대기하는 도중에 지정한 시간이 지나면 해당 작업이 제대로 실행되지 못했다고 기록해두고 일단 종료시킨 다음 큐의 맨 뒤에 다시 추가하는 등의 대책을 세울 수 있다
      이런 경우 성공하건 성공하지 못하건 작업은 계속 움직이며 큐에 쌓여있던 금방 끝나는 작업을 실행할수있도록 스레드를 비워주는 효과가 있다.

## 8.2 스레드 풀 크기 조정
- 스레드풀의 가장 이상적인 크기는 스레드풀에서 실행할 작업의 종류와 스레드 풀을 활용할 애플리케이션의 특성에 따라 결정한다.
- 하드코딩하여 고정하는 방법은 좋은 방법이 아니며 설정파일이나 Runtime.availableProcessors 등의 메소드 결과 값에 따라 동적으로 지정해야 한다.
- 특별한 공식은 없고 너무 크다/ 너무 작다 와 같이 극단적인 크기만 아니면 됨

      스레드 풀의 크기를 적절하게 산정하는 법
      - 처리해야 할 작업이 시작해서 끝날때까지 실제 작업하는 시간 대비 대기 시간의 비율을 구해봐야 함
      - 컴퓨터 환경이 어느정도인지 확인하고, 확보하고 있는 자원의 양과 해야 할 작업이 어떻게 동작하는지도 알아야한다.
      - 처리할 작업의 종류가 다양하다면 각자의 작업 부하에 따라 섬세하게 성능을 조절할 수 있도록 여러개의 스레드풀을 만들어 활용하는 방법도 있다.
      - CPU를 많이 사용하는 작업의 경우 : N개의 CPU를 탑재하고 있는 하드웨어에서 스레드 풀을 사용할 때는 스레드의 개수를 N+1로 맞추면 최적의 성능을 발휘
      - I/O 작업이 많거나 블로킹 작업을 해야하는 경우 : 스레드 풀의 크기를 훨씬 크게 잡아야하는 필요가 있음

      * 스레드풀의 크기를 구하는 수식
        Ncpu = CPU의 개수
        Ucpu = 목표로 하는 CPU 활용도 (0 <= Ucpu <= 1)
        W/C = 작업시간 대비 대기시간의 비율
        
        Nthread = Ncpu * Ucpu * (1+W/C)
        
       * CPU 의 개수는 Runtime클래스의 availableProcessors 메소드로 알수있다.
        int N_CPUS = Runtime.getRuntime().availableProcessors();
        

## 8.3 ThreadPoolExecutor 설정
  **ThreadPoolExecutor : Executors 클래스에 들어있는 newCachedTreadPool, newFixedTrheadPool, newScheduledThreadPool과 같은 팩토리 메소드에서 생성해주는 Executor에 대한 기본적인 내용이 구현되어 있는 클래스이다. 유연하면서도 안정적이고 여러가지 설정을 통해 입맛에 맞게 바꿔 사용할수있다.

### 8.3.1 스레드 생성과 제거
풀의 코어 크기나 최대 크기, 스레드 유지 시간 등의 값을 통해 스레드가 생성되고 제거되는 과정을 조절할수있다.
코어 크기: 스레드 풀을 사용할때 원하는 스레드의 개수
  - 스레드 풀 클래스는 실행할 작업이 없다하더라도 스레드의 개수를 최대한 코어 크기에 맞추도록 되어있다.
  - 큐에 작업이 가득 차지 않는 이상 스레드의 수가 코어 크기를 넘지 않는다.
  - 풀의 최대 크기는 동시에 얼마나 많은 개수의 스레드가 동작할수있는지를 제한하는 최대값이다. 풀의 스레드 개수가 코어 크기를 넘어설때 제거될수있다.
### 8.3.2 큐에 쌓인 작업 관리
### 8.3.3 집중 대응 정책
### 8.3.4 스레드 팩토리
### 8.3.2 ThreadPoolExecutor 생성 이후 설정 변경

## 8.4 ThreadPoolExecutor 상속
ThreadPoolExecutor는 애초에 상속받아 기능을 추가할수있도록 만들어졌다.
하위 클래스가 오버라이드해 사용할 수 있도록 beforeExecute, afterExecute, terminated와 같은 여러가지 훅도 제공하고 있고 이런것들을 사용해 훨씬 다양한 기능을 구사할수있다.

**beforeExecute, afterExecute 메소드**
- 작업을 실행할 스레드의 내부에서 호출하도록 되어 있으며, 로그 메시지를 남기거나 작업 실행 시점이 언제인지 기록해두거나 실행 상태를 모니터링 하거나 기타 다양한 통계 값을 뽑는 등의 작업을 하기에 적당하다
- 특히 afterExecute 메소드는 run 메소드가 정상적으로 종료되거나 아니면 예외가 발생해 Exception을 던지고 종료되는 등의 어떤 상황에서도 항상 호출됨
- Error 때문에 작업이 중단되면 afterExecute 메소드가 실행되지 않음
- beforeExecute에서 RuntimeException이 발생하면 해당 작업도 실행되지 않고 afterExecute 메소드 역시 실행되지 않음
**terminated 메소드**
- 스레드 풀이 종료 절차를 마무리한 이후, 즉 모든 작업과 모든 스레드가 종료되고 나면 terminated 훅 메소드를 호출함
- Executor가 동작하는 과정에서 사용했던 각종 자원을 반납하는 등의 일을 처리하거나 여러가지 알람이나 로그 출력, 다양한 통계 값을 확보하는 등의 작업을 진행하기에 적당한 메소드이다.

### 예제 : 8.4.1 스레드 풀에 통계 확인 기능 추가
- beforeExecute, afterExecute, terminated 메소드를 활용해 구현된 예제
~~~java

~~~
## 8.5 재귀 함수 병렬화

## 참고
책 자바 병렬 프로그래밍 8장
