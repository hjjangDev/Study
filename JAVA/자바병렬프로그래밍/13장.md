

## 13장 명시적인 락
- ReentrantLock: 자바 5.0에 추가된 방법으로 암묵적인 락으로 할수없는 일도 처리할수 있도록 여러 가지 고급 기능을 갖고 있다.

## 13.1 Lock과 ReentrantLock
~~~java
public interface Lock{
    void lock();
    void lockInterruptibly() throws InterruptedException;
    boolean tryLock();
    boolean tryLock(long timeout, TimeUnit unit) 
        throws InterruptedException;
    void unlock();
    Condition newCondition();
}
~~~
예제 13.1 Lock 인터페이스
- Lock 인터페이스는 암묵적인 락과 달리 조건 없는 unconditional 락, 폴링 락, 타임아웃이 있는 락, 락 확보 대기 상태에 인터럽트를 걸 수 있는 방법 등이 포함돼 있으며, 락을 확보하고 해제하는 모든 작업이 명시적이다.
- Lock을 구현하는 클래스는 항상 암묵적인 락과 비교해서 동일한 메모리 가시성 memory visibility 을 제공해야 하지만, 락을 거는 의미나 스케줄링 알고리즘, 순서를 지켜주는 기능, 성능 등의 측면에서 다른 면모를 갖고 있다.

- ReentrantLock 클래스 역시 Lock 인터페이스를 구현하며, synchronized 구문과 동일한 메모리 가시성과 상호 배제 기능을 제공한다.
- ReentrantLock을 확보한다는것은 synchronized 블록에 진입하는것과 동일한 효과를 갖고 있고, ReentrantLock을 해제한다는것은 synchronized 블록에서 빠져나가는것과 동일한 효과를 갖는다. 
- ReentrantLock 역시 synchronized 키워드와 동일하게 재진입이 가능하도록 허용하고 있다.
- ReentrantLock 은 Lock에 정의돼 있는 락 확보 방법을 모두 지원한다. 따라서 락을 제대로 확보하기 어려운 시점에 synchronized 블록을 사용할 때 보다 훨씬 능동적으로 대처 할 수 있다.

~~~java
Lock lock = new ReetrantLock();
...
lock.lock();
try{
    // 객체 내부 값을 사용
    //예외가 발생한 경우, 적절하게 내부값을 복원해야 할 수도 있음
}finally{
    lock.unlock();
}
~~~
예제 13.2 ReentrantLock을 사용한 객체 동기화
- 사용할 때 꼭 지켜야 하는, synchronized를 사용하는 암무적인 락보다 좀 복잡한 규칙도 있는데 바로 finally 블록에서 반드시 락을 해제해야 한다.
- finally 블록에서 해제하지 않으면 try구문 내부에서 예외가 발생했을 때 락이 해제되지 않는 경우가 발생한다
- 만약 예외 때문에 해당 객체가 불안정한 상태가 될 수 있다면 try-catch 구문이나 try-finally 구문을 추가로 지정해 안정적인 상태를 유지하도록 해야한다.
- 즉 ReentrantLock을 사용하면 해당하는 블록의 실행이 끝나고 통제권이 해당 블록을 떠나는 순간 락을 자동으로 해제하지 않기 때문에 굉장히 위험한 코드가 될 가능성이 높다.

## 13.1.1 폴링과 시간 제한이 있는 락 확보 방법
- tryLock 메소드가 지원하는 폴링 락 확보 방법이나 시간 제한이 있는 락 확보 방법은 오류가 발생했을 때 무조건적으로 락을 확보하는 방법보다 오류를 잡아내기에 훨씬 깔끔한 방법이다.
- 암묵적인 락을 사용할때에는 데드락이 발생하면 프로그램이 멈춰버리는 치명적인 상황에 이른다.
- 락을 확보할 때 시간 제한을 두거나 폴링 방법(tryLock)을 사용하면 락을 확보하지 못하는 상황에도 통제권을 다시 얻을 수 있으며, 그러면 미리 확보하고 있던 락을 해제하는 등의 작업을 처리한 이후 락을 다시 확보하도록 재시도할 수 있다.

~~~java
public boolean trnsferMoney(Account fromAcct, Account toAcct, DollarAmount amount, long timeout, TimeUnit unit) throws InsufficientFundsException, IntrerruptedException{

    long finxedDelay = getFixedDelayComponentNanos(timeout, unit);
    long randMod = getRandomDelayModulusNanos(timeout, unit(l
    long stopTime = System.nanoTime() + unit.toNanos(timeout);
    
    while(true) {
        if(fromAcct.lock.tryLock()){
            try{
                if(toAcct.lock.tryLock()){
                    try{
                        if(fromAcct.getBalance().compareTo(amount)<0){
                            throw new InsufficientFundsException();
                        }
                        else {
                            fromAcct.debit(amount);
                            toAcct.credit(amount);
                            return true;
                        }
                    } finally{
                        toAcct.lock.unlock();
                    }
                }
            } finally {
                fromAcct.lock.unlock();
            }
        }
        if(System.nanoTime() >= stopTime)
            return false;
        NONOSECOND.sleep(finxedDelay + rnd.nextLong() % randMod);
    }
}
~~~
예제 13.3 tryLock 메소드로 락 정렬 문제 해결 (동적인 락 정렬 문제로 인해 데드락이 발생했을 때 이런 상황을 피해갈 수 있는 방법)
- tryLock 메소드로 양쪽 락을 모두 확보하도록 돼있지만, 양쪽 모두 확보할 수 없다면 잠시 대기했다가 재시도하도록 돼있다.
- 대기하는 시간 간격은 라이브락이 발생할 확률을 최대한 줄일 수 있도록 고정된 시간 또는 임의의 시간만큼 대기한다.
- 만약 지정된 시간 이내에 락을 확보하지 못했다면 transferMoney 메소드는 오류가 발생했다는 정보를 리턴해주고, 적절한 통제하에서 오류를 처리할 수 있다.


- 일정한 시간을 두고 객체를 관리하는 기능을 구현할 때 시간 제한이 있는 락을 적용하면 유용하다.
- 일정 시간 이내에 실행돼야 하는 코드에서 대기 상태에 들어갈 수 있는 블로킹 메소드를 호출해야 한다면 지정된 시간에서 현재 남아있는 시간만큼을 타임아웃으로 지정할 수 있겠다.
- 그러면 지정된 시간 이내에 결과를 내지 못하는 상황이 되면 알아서 기능을 멈추고 종료되도록 만들 수 있다.
- 반면 암묵적인 락을 사용했다면 일단 락을 확보하고자 시도하게 되면 멈출수가 없기 때문에 정해진 시간 안에 처리해야하는 작업을 맡기기엔 위험도가 높다.

~~~java
public boolean trySendOnSharedLine(String message, long timeout, TimeUnit unit) throws InterruptedException {
    long nanosToLock = unit.toNanos(timeout) - estimatedNanosToSend(message);
    if(!lock.tryLock(nanosToLock, NANOSECONDS)){
        return false;
    }
    try{
        return sendOnSharedLine(message);
    } finally{
        lock.unlock();
    }
}
~~~
예제 13.4 일정 시간 이내에 락을 확보하는 모습 (Lock으로 막혀 있는 공유된 통신 자원을 통해 메시지를 전송하는 방법)
- 일정 시간 이내에 작업을 처리하지 못하면 무리없이 적절한 방법으로 오류를 처리한다.
- tryLock 메소드에 타임아웃을 지정해 사용하면 시간이 제한된 작업 구조에 락을 함게 적용해 활용하기 좋다.

## 13.1.2 인터럽트 걸 수 있는 락 확보 방법
- 작업 도중 취소시킬 수 있어야 하는 작업인 경우에는 인터럽트를 걸 수 있는 락 확보 방법을 유용하게 사용할 수 있다.
- 암묵적인 락을 확보하는 것과 같은 작업은 인터럽트에 전혀 반응하지 않는다.
- lockInterruptibly 메소드를 사용하면 인터럽트는 그대로 처리할 수 있는 상태에서 락을 확보한다. 그리고 Lock 인터페이스에 lockInterruptibly 메소드를 포함하고 있기 때문에 인터럽트에 반응하지 않는 또 다른 종류의 블로킹 구조를 만들어야 할 필요가 없게 됐다.
- 인터럽트에 대응할 수 있는 방법으로 락을 확보하는 코드의 구조는 일반적으로 락을 확보하는 모습보다 약간 복잡하긴 한데, 두개의 try 구문을 사용해야한다.

~~~java
public boolean sendOnSharedLine(String message) throws InterruptedException {
    
    lock.lockInterruptibly();
    try{
        return cancellableSendOnSharedLine(message);
    } finally{
        lock.unlock();
    }
}

private boolean cancellableSendOnSharedLine(String message)
    throws InterruptedException {...}
~~~
예제 13.5 인터럽트를 걸 수 있는 락 확보 방법
- lockInterruptibly를 사용해 예제 13.4에서 구현했던 sendOnSharedLine 메소드를 구현했으며, 취소 가능한 작업으로 실행된다.
- 타임아웃을 지정하는 tryLock 메소드 역시 인터럽트를 걸면 반응하도록 돼 있으며, 인터럽트를 걸어 취소시킬 수도 있어야 하면서 동시에 타임아웃을 지정할 수 있어야 한다면 tryLock을 사용하는것만으로도 충분하다.

## 13.1.3 블록을 벗어나는 구조의 락
- 암묵적인 락을 사용하는 경우에는 락을 확보하고 해제하는 부분이 완벽하게 블록의 구조에 맞춰져 있으며, 블록을 어떤 상태로 떠나는지에 관계 없이 락은 항상 자신을 확보했던 블록이 끝나는 시점에 자동으로 해제된다.
- 이렇게 자동으로 락을 해제하도록 돼있으면 프로그램 코드 분석 과정을 간략하게 줄일 수도 있고, 실수로 락을 해제하지 않아 발생하는 코드상의 오류를 줄일 수도 있다.
- 연결 리스트 linked list 역시 해시 컬렉션과 마찬가지로 락을 세분화 할 수 있는데, 예를 들어 각각의 개별 노드마다 서로 다른 락을 적용할 수 있다. 그러면 각 스레드가 연결 리스트의 서로 다른 부분에 동시에 접근해 사용할 수 있다.
- 특정 노드에 대한 락은 해당 노드가 갖고 있는 링크 포인터와 실제 값을 보호한다. 따라서 링크를 따라가는 알고리즘을 실행하거나 리스트 연결 구조를 변경할 때는 특정 노드에 대한 락을 먼저 확보하고, 그 노드에 연결된 다른 노드에 대한 락을 확보한 다음 원래 노드에 대한 락을 해제해야 한다.
- 이런 방법을 핸드 오버락 또는 락 커플링이라고 부른다.

## 13.2 성능에 대한 고려 사항
- 자바 6에서는 암묵적인 락을 관리하는 부분에 ReentrantLock에서 사용하는 것과 같이 좀 더 향상된 알고리즘을 사용하며, 그에 따라 확장성에서 큰 차이가 나던 것이 많이 비슷해졌다.

** 그림 13.1 (자바 5.0과 자바 6에서 암묵적인 락과 ReentrantLock의 성능 비교) 참고
- 표시된 곡선은 특정 자바 버전에서 암묵적인 락에 비해 ReentrantLock의 성능이 얼마나 좋아지는지 확인할수있다.
- 자바 6에서는 ReentrantLock과 암묵적인 락의 차이가 많이 줄었다는 사실을 알수있따.
- 자바 5.0에서는 암묵적인 락을 사용할 때 스레드 수가 1일 때 보다 스레드 개수가 늘어나면 성능이 크게 떨어진다.
- 대신 ReentrantLock을 사용하면 성능이 떨어지는 정도가 훨씬 덜하며, 따라서 확장성이 더 낫다고 볼 수 있다.
- 반면 자바 6에서는 암묵적인 락을 새용했다 해도 스레드 간의 경쟁이 있는 상황에서 성능이 그다지 떨어지지 않고, ReentrantLock을 사용할 때와 별반 차이가 없다.
- 성능과 확장성은 모두 CPU의 종류, CPU의 개수, 캐시의 크기, JVM의 여러가지 특성 등에 따라 굉장히 민감하게 바뀌기 때문이며, 성능과 확장성에 영향을 주는 여러가지 요인은 시간이 지나면서 계속해서 바뀌게 마련이다.

** 성능 측정 결과는 움직이는 대상이다. 바로 어제 X가 Y보다 빠르다는 결과를 사눌했던 성능 테스트를 오늘 실행해보면 다른 결과를 얻을 수도 있다. **

## 13.3 공정성
- ReentrantLock 클래스는 두 종류의 공정성 설정을 지원한다.
- 불공정 락, 다른 방법은 공정한 방법이다. (기본 값은 불공정)
- 공정한 방법을 사용할 때는 요청한 순서를 지켜가면서 락을 확보하게 된다.
- 불공정한 방법을 사용하는 경우에는 순서 뛰어넘기가 일어나기도 하는데, 락을 확보하려고 대기하는 큐에 대기중인 스레드가 있다 하더라도 해제된 락이 있으면 대기자 목록을 뛰어 넘어 락을 확보할 수 있다.
- 그렇다고 해서 불공정한 ReentrantLock이 일부러 순서를 뛰어 넘도록 하지는 않으며, 대신 딱 맞는 타이밍에 락이 해제된다 해도 큐의 뒤쪽에 있어야 할 스레드가 순서를 뛰어넘지 못하게 제한하지 않을뿐이다.
- 공정한 방법을 사용하면 확보하려는 락을 다른 스레드가 사용하고 있거나 동일한 락을 확보하려는 스레드가 큐에 대기하고 있으면 항상 큐의 맨 뒤에 쌓인다.
- 불공정한 방법이라면 락이 당장 사용 중인 경우에만 큐의 대기자 목록에 들어간다.
- 락을 관리하는 입장에서 봤을 때 공정하게만 처리하다 보면 스레드를 반드시 멈추고 다시 실행시키는 동안에 성능에 큰 지장을 줄 수 있다.
- 실제로 보면 통계적인 공정함 정도만으로도 충분히 괜찮은 결과를 얻을 수 있고, 그에 더불어 성능에도 훨씬 악영향이 적다.
- 일부 알고리즘은 제대로 동작하기 위해서는 반드시 순서를 지켜야 하는 경우도 있지만, 항상 공정하게 순서를 지켜야만 하는 것은 아니다.
- 대부분의 경우 공정하게 순서를 관리해서 얻는 장점보다 불공정하게 ㅓ리해서 얻는 성능상의 이점이 크다

** 그림 13.2 공정한 락과 불공정한 락의 성능 비교 참고
- 스레드 의 경쟁이 심하게 나타나는 상황에서 락을 공정하게 관리하는 것보다 불공정하게 관리하는 방법의 성능이 훨씬 빠른 이유는 대기 상태에 있던 스레드가 다시 싫애상태로 돌아가고 또한 실제로 실행되기까지는 상당한 시간이 걸리기 때문이다.
- 공정한 방법으로 락을 관리할 때는 락을 확보하고 사용하는 시간이 상대적으로 길거나 락 요청이 발생하는 시간 간격이 긴 경우에 유리하다.
- 락 사용시간이 길거나 요청 간의 시간 간격이 길면 순서 뛰어넘기 방법으로 성능상의 이득을 얻을 수 있는 상태 즉 락이 해제돼 있는 상태에서 다른 스레드가 해당 락을 확보하고자 대기 상태에서 깨어나고 있는 상태가 상대적으로 훨씬 덜 발생하기 때문이다.

- 기본 ReentrantLock과 같이 암묵적인 락 역시 공정성에 대해 아무런 보장을 하지 않는다.
- 통계적으로 공정하다는 사실을 놓고 보면 대부분의 락 구현 방법을 거의 모든 상황에 무리없이 적용할 수 있다.
- 자바 언어 명세를 보면 JVM이 암묵적인 락을 구현할 때 반드시 공정하게 구현해야 한다고 명시하지는 않으며, 실제로 제품화돼있는 JVM 가운데 공정하게 구현돼 있는 경우는 없다고 볼 수 있다. 
- ReentrantLock 클래스가 공정성 문제를 불러일으킨건 아니고 계속 존재했던 문제를 명확하게 표현했을 뿐이다.

## 13.4 synchronized 또는 ReentrantLock 선택
- ReentrantLock은 락 능력이나 메모리 측면에서 synchronized 블록과 동일한 형태로 동작하면서도 락을 확보할 때 타임아웃을 지정하거나 대기 상태에서 인터럽트에 잘 반응하고 공정성 여부를 지정할 수도 있으며 블록의 구조를 갖추고 있지 않은 경우에도 락을 적용할 수 있는 유연함을 갖고 있따.
- ReentrantLock을 사용했을 때의 성능이 synchronized를 사용했을때보다 낫다고 판단되는데, 자바 5.0에서는 아주 큰 차이로 성능이 앞섰지만 자바 6에서는 그다지 큰 차이가 있지는 않다.
- 암묵적인 락은 명시적인 락에 비해서 상당한 장점을 갖고있다. 코드에 나타나는 표현 방법도 훨씬 익숙하면서 간결하고 현재 만들어져 있는 대다수의 프로그램이 암묵적인 락을 사용하고 있으니 암묵적인 락과 명시적인 락을 섞어 쓴다고 하면 코드를 읽을 때 굉장히 혼동될 뿐만 아니라 오류가 발생할 가능성도 더 높아진다.
- ReentrantLock은 synchronized 블록에서 제공하지 않는 특별한 기능이 꼭 ㅣㄹ요할 때만 사용하는 편이 안전하다고 본다.


## 요약


## 참고
책 자바 병렬 프로그래밍 13장
