

## 13장 명시적인 락
- ReentrantLock: 자바 5.0에 추가된 방법으로 암묵적인 락으로 할수없는 일도 처리할수 있도록 여러 가지 고급 기능을 갖고 있다.

## 13.1 Lock과 ReentrantLock
~~~java
public interface Lock{
    void lock();
    void lockInterruptibly() throws InterruptedException;
    boolean tryLock();
    boolean tryLock(long timeout, TimeUnit unit) 
        throws InterruptedException;
    void unlock();
    Condition newCondition();
}
~~~
예제 13.1 Lock 인터페이스
- Lock 인터페이스는 암묵적인 락과 달리 조건 없는 unconditional 락, 폴링 락, 타임아웃이 있는 락, 락 확보 대기 상태에 인터럽트를 걸 수 있는 방법 등이 포함돼 있으며, 락을 확보하고 해제하는 모든 작업이 명시적이다.
- Lock을 구현하는 클래스는 항상 암묵적인 락과 비교해서 동일한 메모리 가시성 memory visibility 을 제공해야 하지만, 락을 거는 의미나 스케줄링 알고리즘, 순서를 지켜주는 기능, 성능 등의 측면에서 다른 면모를 갖고 있다.

- ReentrantLock 클래스 역시 Lock 인터페이스를 구현하며, synchronized 구문과 동일한 메모리 가시성과 상호 배제 기능을 제공한다.
- ReentrantLock을 확보한다는것은 synchronized 블록에 진입하는것과 동일한 효과를 갖고 있고, ReentrantLock을 해제한다는것은 synchronized 블록에서 빠져나가는것과 동일한 효과를 갖는다. 
- ReentrantLock 역시 synchronized 키워드와 동일하게 재진입이 가능하도록 허용하고 있다.
- ReentrantLock 은 Lock에 정의돼 있는 락 확보 방법을 모두 지원한다. 따라서 락을 제대로 확보하기 어려운 시점에 synchronized 블록을 사용할 때 보다 훨씬 능동적으로 대처 할 수 있다.

~~~java
Lock lock = new ReetrantLock();
...
lock.lock();
try{
    // 객체 내부 값을 사용
    //예외가 발생한 경우, 적절하게 내부값을 복원해야 할 수도 있음
}finally{
    lock.unlock();
}
~~~
예제 13.2 ReentrantLock을 사용한 객체 동기화
- 사용할 때 꼭 지켜야 하는, synchronized를 사용하는 암무적인 락보다 좀 복잡한 규칙도 있는데 바로 finally 블록에서 반드시 락을 해제해야 한다.
- finally 블록에서 해제하지 않으면 try구문 내부에서 예외가 발생했을 때 락이 해제되지 않는 경우가 발생한다
- 만약 예외 때문에 해당 객체가 불안정한 상태가 될 수 있다면 try-catch 구문이나 try-finally 구문을 추가로 지정해 안정적인 상태를 유지하도록 해야한다.
- 즉 ReentrantLock을 사용하면 해당하는 블록의 실행이 끝나고 통제권이 해당 블록을 떠나는 순간 락을 자동으로 해제하지 않기 때문에 굉장히 위험한 코드가 될 가능성이 높다.

## 13.1.1 폴링과 시간 제한이 있는 락 확보 방법
- tryLock 메소드가 지원하는 폴링 락 확보 방법이나 시간 제한이 있는 락 확보 방법은 오류가 발생했을 때 무조건적으로 락을 확보하는 방법보다 오류를 잡아내기에 훨씬 깔끔한 방법이다.
- 암묵적인 락을 사용할때에는 데드락이 발생하면 프로그램이 멈춰버리는 치명적인 상황에 이른다.
- 락을 확보할 때 시간 제한을 두거나 폴링 방법(tryLock)을 사용하면 락을 확보하지 못하는 상황에도 통제권을 다시 얻을 수 있으며, 그러면 미리 확보하고 있던 락을 해제하는 등의 작업을 처리한 이후 락을 다시 확보하도록 재시도할 수 있다.

~~~java
public boolean trnsferMoney(Account fromAcct, Account toAcct, DollarAmount amount, long timeout, TimeUnit unit) throws InsufficientFundsException, IntrerruptedException{

    long finxedDelay = getFixedDelayComponentNanos(timeout, unit);
    long randMod = getRandomDelayModulusNanos(timeout, unit(l
    long stopTime = System.nanoTime() + unit.toNanos(timeout);
    
    while(true) {
        if(fromAcct.lock.tryLock()){
            try{
                if(toAcct.lock.tryLock()){
                    try{
                        if(fromAcct.getBalance().compareTo(amount)<0){
                            throw new InsufficientFundsException();
                        }
                        else {
                            fromAcct.debit(amount);
                            toAcct.credit(amount);
                            return true;
                        }
                    } finally{
                        toAcct.lock.unlock();
                    }
                }
            } finally {
                fromAcct.lock.unlock();
            }
        }
        if(System.nanoTime() >= stopTime)
            return false;
        NONOSECOND.sleep(finxedDelay + rnd.nextLong() % randMod);
    }
}
~~~
예제 13.3 tryLock 메소드로 락 정렬 문제 해결 (동적인 락 정렬 문제로 인해 데드락이 발생했을 때 이런 상황을 피해갈 수 있는 방법)
- tryLock 메소드로 양쪽 락을 모두 확보하도록 돼있지만, 양쪽 모두 확보할 수 없다면 잠시 대기했다가 재시도하도록 돼있다.
- 대기하는 시간 간격은 라이브락이 발생할 확률을 최대한 줄일 수 있도록 고정된 시간 또는 임의의 시간만큼 대기한다.
- 만약 지정된 시간 이내에 락을 확보하지 못했다면 transferMoney 메소드는 오류가 발생했다는 정보를 리턴해주고, 적절한 통제하에서 오류를 처리할 수 있다.

- 일정한 시간을 두고 객체를 관리하는 기능을 구현할 때 시간 제한이 있는 락을 적용하면 유용하다.
- 일정 시간 이내에 실행돼야 하는 코드에서 대기 상태에 들어갈 수 있는 블로킹 메소드를 호출해야 한다면 지정된 시간에서 현재 남아있는 시간만큼을 타임아웃으로 지정할 수 있겠다.
- 그러면 지정된 시간 이내에 결과를 내지 못하는 상황이 되면 알아서 기능을 멈추고 종료되도록 만들 수 있다.

## 요약


## 참고
책 자바 병렬 프로그래밍 13장
